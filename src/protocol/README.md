# Framed Mobile App Protocol

> Oh, you were expecting a simple protocol with no security? Yeah, I might've put too much effort into this.

## Glossary

Client: The Framed mobile app
Server: The Framed desktop app

## Multicast Packets

In order to announce itself on your network, the server sends a multicast packet to `228.182.166.121:19555` every second to every IPv4 network interface. The packet format is as follows:

`Framed|+|{{install id}}|+|{{json}}`

The separator `|+|` was chosen as it is unlikely to ever appear in packets.

The JSON contains the following:

| Property | Value |
| -------- | ----- |
| messageType | The string `identify` |
| ip | The computer's IP address |
| port | The port the server is listening on |
| hostname | The computer's hostname |
| version | The server's version |
| minClientVersion | The minimum client version the server supports |
| publicKey | A public key generated by the server on initial open |
| sig | A base64 encoded SHA256 signature of this JSON object (stringified), excluding `publicKey` and `sig`

**Important**: An attacker could use an MITM attack replacing the public key and signature with their own. For this reason, a verification step should be used on the client. Framed uses the first 6 characters of a modified* base64 encoded hash of the public key, and the user must enter this code in the mobile app or scan the QR code representation of it.

*The following modifications are done: the string is uppercased, `+` is replaced with `X`, `/` is replaced with `Z`, and vowels (`A, E, I, O, U, Y`) are replaced with the next alphabet character.

**Note**: The order of the JSON object is important for the signatures to match. Therefore a custom JSON object is used on both the server and the client. The `@truewinter/orderedjson` package is used to achieve this. Clients should remove `publicKey` and `sig` without causing invalid JSON or changing the order of the JSON object as this would invalidate the signature. The Java app uses the following regex to achieve this: `,?"***":"[a-zA-Z0-9=_\-+\/]+"`, where `***` is the key to remove.

## Unicast Packets

Unicast packets follow a similar format to multicast packets.

`Framed|+|{{install id}}|+|{{AES IV}}|+|{{encrypted json}}

For the inital key exchange, the IV is replaced with the String `KeyExchange`.

A new IV is used for every message. The encrypted JSON is base64 encoded after encryption. AES-256-CBC is used for encryption.

The JSON contents depend on the `messageType`:

### KeyExchange

Direction: Client to Server

| Property | Value |
| -------- | ----- |
| messageType | The string `KeyExchange` |
| key | The symmetric key for this connection |

### GetPerfData

Direction: Client to Server

| Property | Value |
| -------- | ----- |
| messageType | The string `GetPerfData` |

### PerfData

Direction: Server to Client

| Property | Value |
| -------- | ----- |
| messageType | The string `PerfData` |
| data | The performance data |

### GetDiagData

Direction: Client to Server

| Property | Value |
| -------- | ----- |
| messageType | The string `GetDiagData` |
| lastTimestamp | The last received timestamp, or 0 |

### DiagData

Direction: Server to Client

| Property | Value |
| -------- | ----- |
| messageType | The string `DiagData` |
| data | The diagnostics data |

> Note: The diagnostics data is sorted by the key (a timestamp), and the largest timestamp is saved to be sent as the `lastTimestamp` property in the `GetDiagData` message. By doing this, only new diagnostics data get sent to the client.

## Implementation Details

The first time a user opens Framed (desktop), a public and private key is generated. An installation ID is also generated.

The client identifies servers by their installation ID. After connecting to a server, all packets must contain the installation ID. If it does not match the actual installation ID, the packet is dropped.

After connecting to a server, the client sends a `KeyExchange` packet. This contains a random key encrypted with the server's public key. This random key is used to encrypt all messages in this connection. (See security note in the multicast packets section)

The `KeyExchange` packet must be sent before any more messages are sent. If the server does not have a key for a connection, it will reject messages.

If no data is exchanged within 10 seconds, the connection is closed by the client. The server forcefully closes the connection after 10.25 seconds of inactivity.